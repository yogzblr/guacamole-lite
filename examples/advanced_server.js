#!/usr/bin/env node

/**
 * Guacamole-Lite Advanced Server Example
 *
 * This example demonstrates a production-grade implementation of guacamole-lite with
 * several advanced features commonly required in enterprise environments.
 *
 * FEATURES INCLUDED:
 *
 * 1. Session Recording & Cloud Storage (S3):
 *    - Automatically locates the recording file generated by guacd.
 *    - Compresses the recording on-the-fly using Gzip.
 *    - Uploads the compressed recording to AWS S3 using credentials from the token.
 *    - Cleans up local files after successful upload.
 *
 * 2. Webhooks / Postbacks:
 *    - Sends HTTP/HTTPS notifications to a URL specified in the connection settings.
 *    - Triggers on session 'open', 'close', and recording 'save'.
 *    - Supports query parameter templating (injecting action, timestamp, size).
 *
 * 3. Error Tracking (Sentry):
 *    - Integrates with Sentry for centralized error reporting.
 *    - Adds user context (User ID, Session ID) to error reports.
 *
 * 4. Token Validation:
 *    - Checks token expiration to prevent replay attacks.
 *
 * 5. Dynamic Path Configuration:
 *    - Generates 'recording-path' and 'drive-path' dynamically based on
 *      profile IDs and S3 bucket names inside the encrypted token.
 *
 * 6. Graceful Shutdown:
 *    - Handles SIGTERM/SIGINT.
 *    - Waits for active connections to drain before exiting.
 *
 * 7. HTTP Agent Optimization:
 *    - Increases global socket limits for higher throughput on webhooks/uploads.
 *
 * PREREQUISITES:
 * To run this specific example, you need to install these additional dependencies:
 * npm install @sentry/node @aws-sdk/client-s3 @aws-sdk/lib-storage
 */

const GuacamoleLite = require('guacamole-lite');
const http = require('http');
const https = require('https');
const fs = require('fs');
const zlib = require('zlib');
const path = require('path');
const { pipeline } = require('stream');
const { promisify } = require('util');

// Sentry SDK
const Sentry = require('@sentry/node');

// AWS SDK v3
const { S3Client } = require('@aws-sdk/client-s3');
const { Upload } = require('@aws-sdk/lib-storage');

const pipe = promisify(pipeline);
const unlink = promisify(fs.unlink);
const stat = promisify(fs.stat);
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// --- Configuration -----------------------------------------------------------

// 1. Initialize Sentry (Replace DSN with your own or use env var)
// Note: In production, do not hardcode secrets.
const SENTRY_DSN = process.env.SENTRY_DSN || 'https://examplePublicKey@o0.ingest.sentry.io/0';
Sentry.init({ dsn: SENTRY_DSN });

// 2. HTTP Agent Optimization
// Increase max sockets to handle concurrent S3 uploads and webhooks
http.globalAgent.maxSockets = 50;
https.globalAgent.maxSockets = 50;

const websocketOptions = {
    host: '0.0.0.0',
    port: 8080
};

const guacdOptions = {
    host: '127.0.0.1',
    port: 4822
};

const clientOptions = {
    log: {
        level: 'VERBOSE'
    },

    crypt: {
        cypher: 'AES-256-CBC',
        // In production, use process.env.ENCRYPTION_KEY
        key: 'MySuperSecretKeyForParamsToken12'
    },

    // Default settings that apply to all connections unless overridden by token
    connectionDefaultSettings: {
        rdp: {
            'create-drive-path': true,
            'security': 'any',
            'ignore-cert': true,
            'enable-wallpaper': false,
            'create-recording-path': true // Critical for recording feature
        }
    }
};

// --- Callbacks & Logic -------------------------------------------------------

const callbacks = {
    /**
     * Called after token decryption but before connecting to guacd.
     * Used for validation and dynamic configuration.
     */
    processConnectionSettings: function (settings, callback) {
        // Feature: Token Validation
        if (settings.expiration && settings.expiration < Date.now()) {
            console.error('Connection rejected: Token expired');
            return callback(new Error('Token expired'));
        }

        // Feature: Dynamic Path Configuration
        // We expect the token to contain 's3' object and 'profileId'
        if (settings.s3 && settings.s3.bucket) {
            settings.connection['recording-path'] = `/data/recordings/${settings.s3.bucket}`;
        }

        if (settings.profileId) {
            settings.connection['drive-path'] = `/data/recordings/drive/guacamole_pid_${settings.profileId}`;
        }

        callback(null, settings);
    }
};

// Initialize Server
const guacServer = new GuacamoleLite(websocketOptions, guacdOptions, clientOptions, callbacks);

// --- Event Handlers ----------------------------------------------------------

guacServer.on('open', (clientConnection) => {
    sendPostback(clientConnection, 'open');
});

guacServer.on('close', (clientConnection, error) => {
    if (error) {
        logToSentry(clientConnection, error);
    }
    sendPostback(clientConnection, 'close');

    // Attempt to upload recording if configured
    if (hasRecordingConfig(clientConnection)) {
        uploadSessionToS3(clientConnection);
    }
});

// Server-level error handler
guacServer.on('error', (clientConnection, error) => {
    console.error('Server error:', error);
    logToSentry(clientConnection, error);
});

// --- Graceful Shutdown -------------------------------------------------------

process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

function gracefulShutdown() {
    console.log('Received kill signal, shutting down gracefully...');

    // Stop accepting new connections
    guacServer.webSocketServer.close(() => {
        console.log('WebSocket server closed.');
    });

    // Check for active connections periodically
    const checkInterval = setInterval(() => {
        const count = guacServer.activeConnections.size;
        if (count === 0) {
            console.log('No active connections. Exiting.');
            clearInterval(checkInterval);
            process.exit(0);
        } else {
            console.log(`Waiting for ${count} active connections to close...`);
        }
    }, 1000);
}

// --- Helper Functions --------------------------------------------------------

/**
 * Checks if the connection has necessary settings for recording upload
 */
function hasRecordingConfig(clientConnection) {
    const settings = clientConnection.connectionSettings;
    return settings &&
        settings.connection &&
        settings.connection['recording-path'] &&
        settings.connection['recording-name'] &&
        settings.s3;
}

/**
 * Feature: Error Tracking (Sentry)
 * Adds context to the error report before sending to Sentry.
 */
function logToSentry(clientConnection, error) {
    if (!error) return;

    Sentry.withScope((scope) => {
        if (clientConnection && clientConnection.connectionSettings) {
            const settings = clientConnection.connectionSettings;

            if (settings.userId) {
                scope.setUser({ id: settings.userId });
            }

            scope.setTags({
                sessionId: settings.sessionId || 'unknown',
                profileId: settings.profileId || 'unknown',
                connectionId: clientConnection.connectionId
            });

            scope.setExtra('connectionSettings', settings);
        }

        Sentry.captureException(error);
    });
}

/**
 * Feature: Webhooks / Postbacks
 * Sends status updates to an external URL.
 */
function sendPostback(clientConnection, action) {
    const settings = clientConnection.connectionSettings;

    if (!settings || !settings.postbackUrl) return;

    const eventTime = Date.now();
    const recordingSize = clientConnection.recordingSize || 0;

    try {
        const urlObj = new URL(settings.postbackUrl);

        // Template injection for query parameters
        // Replaces ${key} with actual values
        urlObj.searchParams.forEach((value, key) => {
            const newValue = value
                .replace('${action}', action)
                .replace('${time}', eventTime.toString())
                .replace('${size}', recordingSize.toString());
            urlObj.searchParams.set(key, newValue);
        });

        const requestOptions = {
            method: 'GET', // or POST depending on your requirement
            timeout: 5000  // 5s timeout
        };

        const lib = urlObj.protocol === 'https:' ? https : http;

        const req = lib.request(urlObj, requestOptions, (res) => {
            if (res.statusCode >= 200 && res.statusCode < 300) {
                clientConnection.logger.log(clientConnection.logger.logLevel, `Postback '${action}' sent successfully.`);
            } else {
                clientConnection.logger.log(clientConnection.logger.logLevel, `Postback '${action}' failed with status: ${res.statusCode}`);
            }
        });

        req.on('error', (err) => {
            console.error(`Failed to send postback '${action}':`, err.message);
            logToSentry(clientConnection, err);
        });

        req.end();

    } catch (err) {
        console.error('Error constructing postback URL:', err);
    }
}

/**
 * Feature: Session Recording & S3 Upload
 * Compresses and uploads the recording file to S3.
 */
async function uploadSessionToS3(clientConnection) {
    // Wait briefly for guacd to finish flushing the file to disk after connection close
    await delay(1000);

    const settings = clientConnection.connectionSettings;
    const connSettings = settings.connection;

    // Construct local file path
    const rawFile = path.join(connSettings['recording-path'], connSettings['recording-name']);

    // NOTE: guacd appends a number to the recording name (e.g., name.1), but if configured
    // simply, it might be the exact name. In a robust production environment,
    // you should scan the directory for the most recently modified file matching the pattern.
    // For this example, we assume exact match or simple handling.

    // guacd usually creates the file without extension if not provided,
    // but the recording-name logic depends on how guacd is configured.
    // We will try to find the file.

    if (!fs.existsSync(rawFile)) {
        console.warn(`Recording file not found at ${rawFile}. Skipping upload.`);
        return;
    }

    const gzipPath = rawFile + '.gz';

    try {
        // 1. Get file stats
        const fileStats = await stat(rawFile);
        clientConnection.recordingSize = fileStats.size;

        console.log(`Compressing recording (${fileStats.size} bytes): ${rawFile}`);

        // 2. Compress file
        const sourceStream = fs.createReadStream(rawFile);
        const gzipStream = zlib.createGzip();
        const destinationStream = fs.createWriteStream(gzipPath);

        await pipe(sourceStream, gzipStream, destinationStream);

        // 3. Upload to S3
        console.log(`Uploading to S3 bucket: ${settings.s3.bucket}`);

        const s3Client = new S3Client({
            region: settings.s3.region || 'us-east-1',
            credentials: {
                accessKeyId: settings.s3.accessKeyId,
                secretAccessKey: settings.s3.secretAccessKey
            }
        });

        const upload = new Upload({
            client: s3Client,
            params: {
                Bucket: settings.s3.bucket,
                Key: path.basename(rawFile) + '.gz', // Upload as .gz
                Body: fs.createReadStream(gzipPath),
                ContentEncoding: 'gzip',
                ContentType: 'application/octet-stream'
            }
        });

        upload.on("httpUploadProgress", (progress) => {
            // Optional: log progress
        });

        await upload.done();
        console.log(`Upload complete: ${path.basename(gzipPath)}`);

        // 4. Send 'save' postback
        sendPostback(clientConnection, 'save');

        // 5. Cleanup local files
        await unlink(rawFile);
        await unlink(gzipPath);
        console.log('Local recording files cleaned up.');

    } catch (error) {
        console.error('Failed to process/upload recording:', error);
        logToSentry(clientConnection, error);
    }
}
